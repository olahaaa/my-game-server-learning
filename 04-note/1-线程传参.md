# 线程传参

std::thread 的构造函数在启动线程时，默认会把所有参数 `decay-copy`（退化并复制）一份，存到线程内部的“参数包”中，等线程真正运行时，再把这些副本（作为 `rvalue` / 临时对象）传给目标函数。
⚠️ 关键点：即使目标函数希望用引用`const&`，线程内部用的仍是“副本的临时对象”，不是你传进来的原始变量本身。

## 例
```
void f(int i, std::string const& s);
std::thread t(f, 3, "hello");
```
- "hello" 是字面量（const char[6]），退化为 const char*
- std::thread 内部会复制这个指针值（即地址），并在线程启动时用它构造一个 std::string
- 但字面量是静态存储(`static`)的，地址永远有效 → 安全

## 危险情况
```
void oops(int some_param) {
    char buffer[1024];                 // ← 栈上局部数组！
    sprintf(buffer, "%i", some_param);
    std::thread t(f, 3, buffer);       // ← 传的是 buffer 的地址（char*）
    t.detach();                        // 线程独立跑，oops 可能立刻返回！
}
```
- buffer 是局部变量，生命周期仅限于 oops 函数体内
- std::thread 复制了 buffer 的指针值（比如 0x7fff…），但没复制 buffer 内容
- 新线程稍后用这个指针去构造 std::string，但此时 oops 已返回，buffer 所在栈帧被销毁 → 指向的内存是野指针

🎯 类比：你把家门钥匙（指针）复制了一份寄给朋友，让他来取沙发（buffer 内容）；但你寄完钥匙就立刻搬家拆房了——朋友拿着旧钥匙开门，发现房子没了 😅

## 正确处理
```
std::thread t(f, 3, std::string(buffer));  // 👍 显式提前构造 string
```
避免了悬浮指针（指针指向的内存空间已被释放或不再有效）