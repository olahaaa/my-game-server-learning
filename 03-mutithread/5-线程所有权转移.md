# 线程所有权转移
thread是可移动不可复制的

## 从函数中返回线程

```
std::thread f() {
  void some_function();
  return std::thread(some_function); //返回临时对象
}
```
```
std::thread g() {
  void some_other_function(int);
  std::thread t(some_other_function,42);
  return t; //返回局部具名对象，虽然t是左值，但编译器会优先调用移动构造，因为thread不支持复制构造
}
```
- 只要返回的是函数内创建的`std::thread`，就安全；所有权会正确转移。

## 线程所有权转移至函数
```
void f (std::thread)

void g (){
  void some_function();
  //1 临时对象 自动move
  f(std::thread(some_function()));
  //2 具名对象 显示调用move
  std::thread t(some_function);
  f(std::move(t));
}
```

## 两种线程封装

1. 强所有权模型
```
class scoped_thread{
  std::thread t;
public:
  explicit scoped_thread(std::thread t_): t(std::move(t_)){ //值传递，拥有线程，接收 std::thread 并 move 进来
    if(!t.joinable())
      throw std::logic_error(“No thread”);
  }
  ~scoped_thread(){
    t.join();
  }
  scoped_thread(scoped_thread const&)=delete;
  scoped_thread& operator=(scoped_thread const&)=delete;
};
```
- ✅ 线程生命周期 = scoped_thread 对象生命周期
- ✅ 谁创建 scoped_thread，谁就把线程“移交”给它 → 从此不许再碰原 thread 变量
- ✅ 析构时无条件 join：因为设计上不允许出现“不可 join”的情况（构造时已检查）

2. 弱所有权模型
```
class thread_guard{
std::thread& t;
public:
  explicit thread_guard(std::thread& t_):t(t_){} //引用传递，观察/守护线程，接收 std::thread& 引用
  ~thread_guard(){
    if(t.joinable()){
      t.join();
    }
  }
  thread_guard(thread_guard const&)=delete;
  thread_guard& operator=(thread_guard const&)=delete;
};
```
- ✅ 不拥有线程，只是“临时看管”一个已存在的 std::thread 对象
- ✅ 适合：线程创建和 join 分离的场景（例如：中间可能 detach 或异常提前退出）
- ✅ 析构时检查 joinable()：因为外部可能已 detach() 或 join() 过